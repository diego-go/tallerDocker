'use strict';

var _es6Map = require('es6-map');

var _es6Map2 = _interopRequireDefault(_es6Map);

var _getExports = require('../core/getExports');

var _getExports2 = _interopRequireDefault(_getExports);

var _importDeclaration = require('../importDeclaration');

var _importDeclaration2 = _interopRequireDefault(_importDeclaration);

var _declaredScope = require('../core/declaredScope');

var _declaredScope2 = _interopRequireDefault(_declaredScope);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (context) {

  var namespaces = new _es6Map2.default();

  function makeMessage(last, namepath) {
    return '\'' + last.name + '\' not found in' + (namepath.length > 1 ? ' deeply ' : ' ') + ('imported namespace \'' + namepath.join('.') + '\'.');
  }

  return {

    // pick up all imports at body entry time, to properly respect hoisting
    'Program': function Program(_ref) {
      var body = _ref.body;

      function processBodyStatement(declaration) {
        if (declaration.type !== 'ImportDeclaration') return;

        if (declaration.specifiers.length === 0) return;

        var imports = _getExports2.default.get(declaration.source.value, context);
        if (imports == null) return null;

        if (imports.errors.length) {
          imports.reportErrors(context, declaration);
          return;
        }

        declaration.specifiers.forEach(function (specifier) {
          switch (specifier.type) {
            case 'ImportNamespaceSpecifier':
              if (!imports.size) {
                context.report(specifier, 'No exported names found in module \'' + declaration.source.value + '\'.');
              }
              namespaces.set(specifier.local.name, imports);
              break;
            case 'ImportDefaultSpecifier':
            case 'ImportSpecifier':
              {
                var meta = imports.get(
                // default to 'default' for default http://i.imgur.com/nj6qAWy.jpg
                specifier.imported ? specifier.imported.name : 'default');
                if (!meta || !meta.namespace) break;
                namespaces.set(specifier.local.name, meta.namespace);
                break;
              }
          }
        });
      }
      body.forEach(processBodyStatement);
    },

    // same as above, but does not add names to local map
    'ExportNamespaceSpecifier': function ExportNamespaceSpecifier(namespace) {
      var declaration = (0, _importDeclaration2.default)(context);

      var imports = _getExports2.default.get(declaration.source.value, context);
      if (imports == null) return null;

      if (imports.errors.length) {
        imports.reportErrors(context, declaration);
        return;
      }

      if (!imports.size) {
        context.report(namespace, 'No exported names found in module \'' + declaration.source.value + '\'.');
      }
    },

    // todo: check for possible redefinition

    'MemberExpression': function MemberExpression(dereference) {
      if (dereference.object.type !== 'Identifier') return;
      if (!namespaces.has(dereference.object.name)) return;

      if (dereference.parent.type === 'AssignmentExpression' && dereference.parent.left === dereference) {
        context.report(dereference.parent, 'Assignment to member of namespace \'' + dereference.object.name + '\'.');
      }

      // go deep
      var namespace = namespaces.get(dereference.object.name);
      var namepath = [dereference.object.name];
      // while property is namespace and parent is member expression, keep validating
      while (namespace instanceof _getExports2.default && dereference.type === 'MemberExpression') {

        if (dereference.computed) {
          context.report(dereference.property, 'Unable to validate computed reference to imported namespace \'' + dereference.object.name + '\'.');
          return;
        }

        if (!namespace.has(dereference.property.name)) {
          context.report(dereference.property, makeMessage(dereference.property, namepath));
          break;
        }

        // stash and pop
        namepath.push(dereference.property.name);
        namespace = namespace.get(dereference.property.name).namespace;
        dereference = dereference.parent;
      }
    },

    'VariableDeclarator': function VariableDeclarator(_ref2) {
      var id = _ref2.id;
      var init = _ref2.init;

      if (init == null) return;
      if (init.type !== 'Identifier') return;
      if (!namespaces.has(init.name)) return;

      // check for redefinition in intermediate scopes
      if ((0, _declaredScope2.default)(context, init.name) !== 'module') return;

      // DFS traverse child namespaces
      function testKey(pattern, namespace) {
        var path = arguments.length <= 2 || arguments[2] === undefined ? [init.name] : arguments[2];

        if (!(namespace instanceof _getExports2.default)) return;

        if (pattern.type !== 'ObjectPattern') return;

        pattern.properties.forEach(function (property) {
          if (property.key.type !== 'Identifier') {
            context.report({
              node: property,
              message: 'Only destructure top-level names.'
            });
          } else if (!namespace.has(property.key.name)) {
            context.report({
              node: property,
              message: makeMessage(property.key, path)
            });
          } else {
            path.push(property.key.name);
            testKey(property.value, namespace.get(property.key.name).namespace, path);
            path.pop();
          }
        });
      }

      testKey(id, namespaces.get(init.name));
    }
  };
};
//# sourceMappingURL=data:application/json;base64,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SSw2QkFBYyxPQUFkLEVBQXVCLEtBQUssSUFBNUIsTUFBc0MsUUFBMUMsRUFBb0Q7OztBQUdwRCxlQUFTLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEIsU0FBMUIsRUFBeUQ7QUFBQSxZQUFwQixJQUFvQix5REFBYixDQUFDLEtBQUssSUFBTixDQUFhOztBQUN2RCxZQUFJLEVBQUUseUNBQUYsQ0FBSixFQUFxQzs7QUFFckMsWUFBSSxRQUFRLElBQVIsS0FBaUIsZUFBckIsRUFBc0M7O0FBRXRDLGdCQUFRLFVBQVIsQ0FBbUIsT0FBbkIsQ0FBMkIsVUFBQyxRQUFELEVBQWM7QUFDdkMsY0FBSSxTQUFTLEdBQVQsQ0FBYSxJQUFiLEtBQXNCLFlBQTFCLEVBQXdDO0FBQ3RDLG9CQUFRLE1BQVIsQ0FBZTtBQUNiLG9CQUFNLFFBRE87QUFFYix1QkFBUztBQUZJLGFBQWY7QUFJRCxXQUxELE1BS08sSUFBSSxDQUFDLFVBQVUsR0FBVixDQUFjLFNBQVMsR0FBVCxDQUFhLElBQTNCLENBQUwsRUFBdUM7QUFDNUMsb0JBQVEsTUFBUixDQUFlO0FBQ2Isb0JBQU0sUUFETztBQUViLHVCQUFTLFlBQVksU0FBUyxHQUFyQixFQUEwQixJQUExQjtBQUZJLGFBQWY7QUFJRCxXQUxNLE1BS0E7QUFDTCxpQkFBSyxJQUFMLENBQVUsU0FBUyxHQUFULENBQWEsSUFBdkI7QUFDQSxvQkFBUSxTQUFTLEtBQWpCLEVBQXdCLFVBQVUsR0FBVixDQUFjLFNBQVMsR0FBVCxDQUFhLElBQTNCLEVBQWlDLFNBQXpELEVBQW9FLElBQXBFO0FBQ0EsaUJBQUssR0FBTDtBQUNEO0FBQ0YsU0FoQkQ7QUFpQkQ7O0FBRUQsY0FBUSxFQUFSLEVBQVksV0FBVyxHQUFYLENBQWUsS0FBSyxJQUFwQixDQUFaO0FBQ0Q7QUF0SUksR0FBUDtBQXdJRCxDQWxKRCIsImZpbGUiOiJydWxlcy9uYW1lc3BhY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWFwIGZyb20gJ2VzNi1tYXAnXG5cbmltcG9ydCBFeHBvcnRzIGZyb20gJy4uL2NvcmUvZ2V0RXhwb3J0cydcbmltcG9ydCBpbXBvcnREZWNsYXJhdGlvbiBmcm9tICcuLi9pbXBvcnREZWNsYXJhdGlvbidcbmltcG9ydCBkZWNsYXJlZFNjb3BlIGZyb20gJy4uL2NvcmUvZGVjbGFyZWRTY29wZSdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gIGNvbnN0IG5hbWVzcGFjZXMgPSBuZXcgTWFwKClcblxuICBmdW5jdGlvbiBtYWtlTWVzc2FnZShsYXN0LCBuYW1lcGF0aCkge1xuICAgICByZXR1cm4gYCcke2xhc3QubmFtZX0nIG5vdCBmb3VuZCBpbmAgK1xuICAgICAgICAgICAgKG5hbWVwYXRoLmxlbmd0aCA+IDEgPyAnIGRlZXBseSAnIDogJyAnKSArXG4gICAgICAgICAgICBgaW1wb3J0ZWQgbmFtZXNwYWNlICcke25hbWVwYXRoLmpvaW4oJy4nKX0nLmBcbiAgfVxuXG4gIHJldHVybiB7XG5cbiAgICAvLyBwaWNrIHVwIGFsbCBpbXBvcnRzIGF0IGJvZHkgZW50cnkgdGltZSwgdG8gcHJvcGVybHkgcmVzcGVjdCBob2lzdGluZ1xuICAgICdQcm9ncmFtJzogZnVuY3Rpb24gKHsgYm9keSB9KSB7XG4gICAgICBmdW5jdGlvbiBwcm9jZXNzQm9keVN0YXRlbWVudChkZWNsYXJhdGlvbikge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb24udHlwZSAhPT0gJ0ltcG9ydERlY2xhcmF0aW9uJykgcmV0dXJuXG5cbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnNwZWNpZmllcnMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAgICAgICBjb25zdCBpbXBvcnRzID0gRXhwb3J0cy5nZXQoZGVjbGFyYXRpb24uc291cmNlLnZhbHVlLCBjb250ZXh0KVxuICAgICAgICBpZiAoaW1wb3J0cyA9PSBudWxsKSByZXR1cm4gbnVsbFxuXG4gICAgICAgIGlmIChpbXBvcnRzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBpbXBvcnRzLnJlcG9ydEVycm9ycyhjb250ZXh0LCBkZWNsYXJhdGlvbilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGRlY2xhcmF0aW9uLnNwZWNpZmllcnMuZm9yRWFjaCgoc3BlY2lmaWVyKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJzpcbiAgICAgICAgICAgICAgaWYgKCFpbXBvcnRzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlcG9ydChzcGVjaWZpZXIsXG4gICAgICAgICAgICAgICAgICBgTm8gZXhwb3J0ZWQgbmFtZXMgZm91bmQgaW4gbW9kdWxlICcke2RlY2xhcmF0aW9uLnNvdXJjZS52YWx1ZX0nLmApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmFtZXNwYWNlcy5zZXQoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIGltcG9ydHMpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJzpcbiAgICAgICAgICAgIGNhc2UgJ0ltcG9ydFNwZWNpZmllcic6IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGltcG9ydHMuZ2V0KFxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gJ2RlZmF1bHQnIGZvciBkZWZhdWx0IGh0dHA6Ly9pLmltZ3VyLmNvbS9uajZxQVd5LmpwZ1xuICAgICAgICAgICAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA/IHNwZWNpZmllci5pbXBvcnRlZC5uYW1lIDogJ2RlZmF1bHQnKVxuICAgICAgICAgICAgICBpZiAoIW1ldGEgfHwgIW1ldGEubmFtZXNwYWNlKSBicmVha1xuICAgICAgICAgICAgICBuYW1lc3BhY2VzLnNldChzcGVjaWZpZXIubG9jYWwubmFtZSwgbWV0YS5uYW1lc3BhY2UpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgYm9keS5mb3JFYWNoKHByb2Nlc3NCb2R5U3RhdGVtZW50KVxuICAgIH0sXG5cbiAgICAvLyBzYW1lIGFzIGFib3ZlLCBidXQgZG9lcyBub3QgYWRkIG5hbWVzIHRvIGxvY2FsIG1hcFxuICAgICdFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXInOiBmdW5jdGlvbiAobmFtZXNwYWNlKSB7XG4gICAgICB2YXIgZGVjbGFyYXRpb24gPSBpbXBvcnREZWNsYXJhdGlvbihjb250ZXh0KVxuXG4gICAgICB2YXIgaW1wb3J0cyA9IEV4cG9ydHMuZ2V0KGRlY2xhcmF0aW9uLnNvdXJjZS52YWx1ZSwgY29udGV4dClcbiAgICAgIGlmIChpbXBvcnRzID09IG51bGwpIHJldHVybiBudWxsXG5cbiAgICAgIGlmIChpbXBvcnRzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaW1wb3J0cy5yZXBvcnRFcnJvcnMoY29udGV4dCwgZGVjbGFyYXRpb24pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIWltcG9ydHMuc2l6ZSkge1xuICAgICAgICBjb250ZXh0LnJlcG9ydChuYW1lc3BhY2UsXG4gICAgICAgICAgYE5vIGV4cG9ydGVkIG5hbWVzIGZvdW5kIGluIG1vZHVsZSAnJHtkZWNsYXJhdGlvbi5zb3VyY2UudmFsdWV9Jy5gKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyB0b2RvOiBjaGVjayBmb3IgcG9zc2libGUgcmVkZWZpbml0aW9uXG5cbiAgICAnTWVtYmVyRXhwcmVzc2lvbic6IGZ1bmN0aW9uIChkZXJlZmVyZW5jZSkge1xuICAgICAgaWYgKGRlcmVmZXJlbmNlLm9iamVjdC50eXBlICE9PSAnSWRlbnRpZmllcicpIHJldHVyblxuICAgICAgaWYgKCFuYW1lc3BhY2VzLmhhcyhkZXJlZmVyZW5jZS5vYmplY3QubmFtZSkpIHJldHVyblxuXG4gICAgICBpZiAoZGVyZWZlcmVuY2UucGFyZW50LnR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbicgJiZcbiAgICAgICAgICBkZXJlZmVyZW5jZS5wYXJlbnQubGVmdCA9PT0gZGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICBjb250ZXh0LnJlcG9ydChkZXJlZmVyZW5jZS5wYXJlbnQsXG4gICAgICAgICAgICAgIGBBc3NpZ25tZW50IHRvIG1lbWJlciBvZiBuYW1lc3BhY2UgJyR7ZGVyZWZlcmVuY2Uub2JqZWN0Lm5hbWV9Jy5gKVxuICAgICAgfVxuXG4gICAgICAvLyBnbyBkZWVwXG4gICAgICB2YXIgbmFtZXNwYWNlID0gbmFtZXNwYWNlcy5nZXQoZGVyZWZlcmVuY2Uub2JqZWN0Lm5hbWUpXG4gICAgICB2YXIgbmFtZXBhdGggPSBbZGVyZWZlcmVuY2Uub2JqZWN0Lm5hbWVdXG4gICAgICAvLyB3aGlsZSBwcm9wZXJ0eSBpcyBuYW1lc3BhY2UgYW5kIHBhcmVudCBpcyBtZW1iZXIgZXhwcmVzc2lvbiwga2VlcCB2YWxpZGF0aW5nXG4gICAgICB3aGlsZSAobmFtZXNwYWNlIGluc3RhbmNlb2YgRXhwb3J0cyAmJlxuICAgICAgICAgICAgIGRlcmVmZXJlbmNlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuXG4gICAgICAgIGlmIChkZXJlZmVyZW5jZS5jb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRleHQucmVwb3J0KGRlcmVmZXJlbmNlLnByb3BlcnR5LFxuICAgICAgICAgICAgJ1VuYWJsZSB0byB2YWxpZGF0ZSBjb21wdXRlZCByZWZlcmVuY2UgdG8gaW1wb3J0ZWQgbmFtZXNwYWNlIFxcJycgK1xuICAgICAgICAgICAgZGVyZWZlcmVuY2Uub2JqZWN0Lm5hbWUgKyAnXFwnLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5hbWVzcGFjZS5oYXMoZGVyZWZlcmVuY2UucHJvcGVydHkubmFtZSkpIHtcbiAgICAgICAgICBjb250ZXh0LnJlcG9ydChcbiAgICAgICAgICAgIGRlcmVmZXJlbmNlLnByb3BlcnR5LFxuICAgICAgICAgICAgbWFrZU1lc3NhZ2UoZGVyZWZlcmVuY2UucHJvcGVydHksIG5hbWVwYXRoKSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3Rhc2ggYW5kIHBvcFxuICAgICAgICBuYW1lcGF0aC5wdXNoKGRlcmVmZXJlbmNlLnByb3BlcnR5Lm5hbWUpXG4gICAgICAgIG5hbWVzcGFjZSA9IG5hbWVzcGFjZS5nZXQoZGVyZWZlcmVuY2UucHJvcGVydHkubmFtZSkubmFtZXNwYWNlXG4gICAgICAgIGRlcmVmZXJlbmNlID0gZGVyZWZlcmVuY2UucGFyZW50XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgJ1ZhcmlhYmxlRGVjbGFyYXRvcic6IGZ1bmN0aW9uICh7IGlkLCBpbml0IH0pIHtcbiAgICAgIGlmIChpbml0ID09IG51bGwpIHJldHVyblxuICAgICAgaWYgKGluaXQudHlwZSAhPT0gJ0lkZW50aWZpZXInKSByZXR1cm5cbiAgICAgIGlmICghbmFtZXNwYWNlcy5oYXMoaW5pdC5uYW1lKSkgcmV0dXJuXG5cbiAgICAgIC8vIGNoZWNrIGZvciByZWRlZmluaXRpb24gaW4gaW50ZXJtZWRpYXRlIHNjb3Blc1xuICAgICAgaWYgKGRlY2xhcmVkU2NvcGUoY29udGV4dCwgaW5pdC5uYW1lKSAhPT0gJ21vZHVsZScpIHJldHVyblxuXG4gICAgICAvLyBERlMgdHJhdmVyc2UgY2hpbGQgbmFtZXNwYWNlc1xuICAgICAgZnVuY3Rpb24gdGVzdEtleShwYXR0ZXJuLCBuYW1lc3BhY2UsIHBhdGggPSBbaW5pdC5uYW1lXSkge1xuICAgICAgICBpZiAoIShuYW1lc3BhY2UgaW5zdGFuY2VvZiBFeHBvcnRzKSkgcmV0dXJuXG5cbiAgICAgICAgaWYgKHBhdHRlcm4udHlwZSAhPT0gJ09iamVjdFBhdHRlcm4nKSByZXR1cm5cblxuICAgICAgICBwYXR0ZXJuLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgY29udGV4dC5yZXBvcnQoe1xuICAgICAgICAgICAgICBub2RlOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ09ubHkgZGVzdHJ1Y3R1cmUgdG9wLWxldmVsIG5hbWVzLicsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSBpZiAoIW5hbWVzcGFjZS5oYXMocHJvcGVydHkua2V5Lm5hbWUpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlcG9ydCh7XG4gICAgICAgICAgICAgIG5vZGU6IHByb3BlcnR5LFxuICAgICAgICAgICAgICBtZXNzYWdlOiBtYWtlTWVzc2FnZShwcm9wZXJ0eS5rZXksIHBhdGgpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKHByb3BlcnR5LmtleS5uYW1lKVxuICAgICAgICAgICAgdGVzdEtleShwcm9wZXJ0eS52YWx1ZSwgbmFtZXNwYWNlLmdldChwcm9wZXJ0eS5rZXkubmFtZSkubmFtZXNwYWNlLCBwYXRoKVxuICAgICAgICAgICAgcGF0aC5wb3AoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgdGVzdEtleShpZCwgbmFtZXNwYWNlcy5nZXQoaW5pdC5uYW1lKSlcbiAgICB9LFxuICB9XG59XG4iXX0=